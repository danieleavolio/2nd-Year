Bloom Filter can be used if the answer to the below points is yes
There is a predetermined set of items for the hot values.
Data can be separated into records, as in filtering.
A feature can be extracted from each record that could be in a set of hot values.
Some false positives are acceptable
Steps in Bloom Filter
1. Train the Bloom filter from the list of values. This is done by loading the data from where it is stored and adding each item to the Bloom filter. The trained Bloom filter is stored in HDFS at a known location.
2. Do the actual filtering . When the map task starts, it loads the Bloom filter from the distributed cache. Then, in the map function, it iterates through the records and checks the Bloom filter for set membership in the hot values list. Each record is either forwarded or not based on the Bloom filter membership test.

Note : The Bloom filter needs to be re-trained only when the data changes. Therefore, updating the Bloom filter in a lazy fashion is typically appropriate.

Bloom Filter Use Cases
Prefiltering a data set for an expensive set membership check :Sometimes, checking whether some value is a member of a set is going to be expensive.
Removing most of the non watched values : The most straightforward use case is cleaning out values that aren’t hot.Removing most of the non watched values.
Performance Note
The performance for this pattern is going to be very similar to simple filtering from a performance perspective. Loading up the Bloom filter from the distributed cache is not that expensive since the file is relatively small. Checking a value against the Bloom filter is also a relatively cheap operation, as each test is executed in constant time.

Problem to Solve
Given a list of employees details use bloom filter to filter out employees based on the department who are not part of the PUBLIC LIBRARY department hot list.

Here is a sample input data attached which has to be used for training bloom filter bloom_filter_employee_data.txt

Here is a sample input data attached for map reduce processing employee_info.csv

Input Data sample for reference
First Name,Last Name,Job Titles,Department,Full or Part-Time,Salary or Hourly,Typical Hours,Annual Salary,Hourly Rate

dubert,tomasz ,paramedic i/c,fire,f,salary,,91080.00,
edwards,tim p,lieutenant,fire,f,salary,,114846.00,
elkins,eric j,sergeant,police,f,salary,,104628.00,
estrada,luis f,police officer,police,f,salary,,96060.00,
ewing,marie a,clerk iii,police,f,salary,,53076.00,
finn,sean p,firefighter,fire,f,salary,,87006.00,
fitch,jordan m,law clerk,law,f,hourly,35,,14.51

A Bloom filter is trained on the bytes of the word. The important thing of this is that the words “the” and “The” may look the same, but the bytes are different. Unless case sensitivity matters in you algorithm, it is best to trim the string and make the string all lower case when training and testing the filter.

Training Bloom Filter
The following variables are used in the code snippet below:
i – The number of bits in the filter
k – The number of members in the set
l – The desired false positive rate
m – The number of different hash functions used to map some element to one of the i bits with a uniform random distribution.

A Bloom filter is represented by a continuous string of i bits initialized to zero. For each element in k, m hash function values are taken modulo i to achieve an index from zero to i – 1.The bits of the Bloom filter at the resulting indices are set to one. This operation is often called training a Bloom filter. As elements are added to the Bloom filter, some bits may already be set to one from previous elements in the set. When testing whether a member is an element of the set, the same hash functions are used to check the bits of the array. If a single bit of all the hashes is set to zero, the test returns no. If all the bits are turned on, the test returns maybe. If the member was used to train the filter, the m hashs would have set all the bits to one.The result of the test cannot be a definitive yes because the bits may have been turned on by a combination of other elements. If the test returns maybe but should have been no, this is known as a false positive. Thankfully, the false positive rate can be controlled if the number of members in the set is known ahead of time, or at least an approximation of the number of members in the set is known.

In the below code based on the sample data we have around 32658 members in the set and we have set 0.2 as the acceptable false positive.

It can be very beneficial to know an approximation of the number of elements. If you know this ahead of time, a Bloom filter can be sized appropriately to have a hand-picked false positive rate.