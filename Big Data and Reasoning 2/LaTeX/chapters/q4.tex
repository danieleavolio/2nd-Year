\section{Domande: Column and in Memory database}

\begin{domanda}
    Per quale motivo sono nati i database a grafo?
\end{domanda}

I database relazionali immagazzinavano dati e le relazioni che ci sono tra
loro. La controparte di queste relazioni e' il \textbf{grafo}. Ma per modellare
un grafo non era facile con i sistemi di database relazionali. Ancora peggio i
database non relazionali non riuscivano a modellare per bene i grafi,
sopratutto quando si parla di relazioni tra oggetti (non ci sono i join).

Comunque in generale per questa parte non c'e' molto da dire. Cioe' provarono a
costruire dei database basati sui grafi. Avevano alcune proprieta' decenti come
la \textbf{index free adjacency} che permetteva di muoversi all'interno del
grafo con senza dover cercare gli indici. Comunque c'erano dei problemi.

C'erano alcuni engine che permettevano di calcoalre questi grafi:
\begin{itemize}
    \item Apache Giraph
    \item GraphX
    \item Titan
\end{itemize}

\begin{domanda}
    Cos'e RDF
\end{domanda}

RDF significa \textbf{resource description framework RDF}. E' un framework per
rappresentare le informazioni sul web.
\begin{equation}
    entity:attribute:value
\end{equation}

Utilizzala sintassi XML e il linguaggio SPARQL
\begin{lstlisting}[language=SPARQL, caption={Esempio di query SPARQL}]
    SELECT ?object
        FROM <http://example.org>
        WHERE {
            <http://example.org> <http://example.org/property> ?object
        }
\end{lstlisting}

\begin{domanda}
    Differenza tra OLTP e OLAP
\end{domanda}

OLTP sta per \textbf{online transaction processing} e OLAP sta per
\textbf{online analytical processing}. OLTP e' un sistema che permette di
gestire le transazioni ed e' comodo sopratutto quando si ha un carico elevato
di \textbf{transizioni in scrittura}. Gli ecommerce ad esempio sfruttano molto
i sistemi OLTP. I sistemi OLTP hanno uno schema \textbf{row oriented}.

I sistemi OLAP sono piu' utili in caso di sistemi che hanno un elevato numero
di richieste in \textbf{lettura} come ad esempio i software che devono
calcolare spesso medie e misure, come ad esempio i software di business
intelligence e data mining. I sistemi OLAP hanno uno schema \textbf{column
    oriented}.

\begin{domanda}
    Per cosa e' buono avere database row o column
\end{domanda}

Ad esempio, poniamo il caso di avere un database con 10 colonne e a noi
interessa la colonna 'eta'

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        id & nome  & cognome & eta & indirizzo  \\ \hline
        1  & Mario & Rossi   & 20  & Via Roma   \\ \hline
        2  & Luca  & Bianchi & 30  & Via Milano \\ \hline
        3  & Marco & Verdi   & 40  & Via Napoli \\ \hline
    \end{tabular}
\end{table}

Se a noi interessa ad esempio la media delle eta', con un database row oriented
dobbiamo scorrere tutte le righe e prendere la colonna eta' e calcolare la
media. Con un database column oriented invece, abbiamo gia' la colonna eta' e
quindi possiamo calcolare la media direttamente.

\begin{domanda}
    A cosa serviva C-Store Storage e come funzionava
\end{domanda}

C-store sfruttava la ridondanza degli elementi con le proiezioni. Una
proiezione e' una ripetizione di alcune colonne che sono accesse frequentemente
e salvate sul disco. Questo aumentava le performance.

Aveva una pesante compressione delle colonne. Cioe, le colonne venivano
comprese e salvate sul disco. Questo permetteva di avere un accesso piu'
veloce.

\begin{itemize}
    \item C-Store storage utilizza la compressione delle colonne per migliorare le
          prestazioni.
    \item I dati sono archiviati in ordine ordinato e le colonne sono pesantemente
          compresse.
    \item Il sistema utilizza un Writeable (Delta) Store e un Read-Optimized Store per
          gestire le operazioni di scrittura e lettura.
    \item C-Store Storage utilizza la tecnica K-safety per garantire l'affidabilità dei
          dati.
\end{itemize}

\begin{domanda}
    Per quale motivo i sistemi heavy write non funzioano bene su ssd?
\end{domanda}

La risposta e' molto semplice: Per scrivere su SSD bisogna cancellare e
riscrivere. Quindi se si ha un sistema che scrive molto, si avranno molti cicli
di scrittura e cancellazione. Questo ha un effetto di bottleneck sul sistema.

\begin{domanda}
    Database cacheless
\end{domanda}

I database in memoria principale (Main Memory DB) sono progettati per
funzionare senza cache, ovvero senza la necessità di memorizzare
temporaneamente i dati su memoria cache per minimizzare l'accesso ai dati su
disco.

A differenza dei database tradizionali basati su disco, i database in memoria
principale memorizzano tutti i dati direttamente in memoria principale, senza
la necessità di accedere ai dati su disco. In questo modo, l'accesso ai dati è
molto più veloce e non è necessario utilizzare una cache per minimizzare
l'accesso ai dati su disco.

In altre parole, la cache è inutile in un database in memoria principale perché
tutti i dati sono già memorizzati in memoria principale. Non c'è bisogno di
memorizzare temporaneamente i dati su cache perché non c'è bisogno di
minimizzare l'accesso ai dati su disco

\begin{domanda}
    Cosa e' Berkeley Analytics Data Stack
\end{domanda}

BDAS è un insieme di strumenti open source per l'analisi dei dati formato da:
\begin{itemize}
    \item Spark: un framework per l'elaborazione distribuita
    \item Mesos: un sistema operativo per i data center (Gestisce i cluster)
    \item Tachyon: un sistema di file distribuito
\end{itemize}

\begin{domanda}
    Cosa e' SPARK
\end{domanda}

Spark e' un framework che permette di lavorare sui dati in modo distribuito.

Tratta i dati come RDD, cioe' \textit{resilient distributed datasets}. Questi
RDD sono immutabili e sono distribuiti sui nodi del cluster. Spark permette di
fare operazioni su questi RDD in modo parallelo.

Non abbiamo visto ancora niente di Spark, quindi non posso dire altro ad essere onesto.

